# 03 | 事务隔离的四种级别：读未提交）、读提交、可重复读、串行化

事务就是要保证一组数据库操作，要么全部成功，要么全部失败。再MySQL中，事务支持是在引擎层实现的。并不是所有引擎都支持事务。MyISAM不支持事务，这也是MyISAM被InnoDB取代的重要原因。

事务的特性：ACID（Atomicity原子性，Consistency一致性，Isolation隔离性，Durabiility持久性）

当数据库上有多个事务同时执行的时候，可能出现脏读、不可重复读、幻读的问题。为了解决这些问题，就有了“隔离级别”的概念。

### SQL标准的事务隔离级别

SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）、串行化（serializable）。隔离级别的实现是在数据库里**创建视图**，访问的时候以视图的逻辑结果为准。

- **读未提交**：一个事务还没提交时，它做的变更就能被别的事务看到。直接返回记录上的最新值，没有视图概念。
- **读提交**：一个事务提交之后，它做的变更才会被其他事务看到。视图是在每个SQL语句开始执行的时候创建的。
- **可重复读**：事务在执行期间看到的数据是前后一致的，即使此时已经有其他操作修改了数据。这个隔离级别下，视图是在事务启动时创建的，整个事务存在期间都用这个视图。
- **串行化**：对于同一行记录，写加写锁，读加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。直接用加锁的方式来避免并行访问。

*Oracle数据库的默认隔离级别是“读提交”，在迁移到MySQL时，一定要记得把MySQL的隔离级别也设置为“读提交”。*

查看当前隔离级别的命令是：

``` sql
show variables like 'transaction_isolation';
```

每种隔离级别都有自己的使用场景，要根据自己的业务情况来定。

### 事务隔离的实现

在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。如果隔离级别是“可重复读”的事务是在不同时刻启动的，同一条记录就可以在系统里存在多个版本，这就是数据库的多版本并发控制（MVCC)。

回滚日志会在没有事务再需要用到这些回滚日志的时候被删除。

**为什么尽量不要使用长事务：**长事务意味着系统里存在着很老的事务视图。这些事务随时可能访问数据库里的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这会导致大量占用存储空间。同时长事务还占用锁资源，可能会拖垮整个库。

### 事务的启动方式

**显示启动事务**：begin或start transaction。提交语句是commit，回滚语句是commit。set autocommit=0这个命令会将这个线程的自动提交关掉，这会导致随意一个select命令就会启动事务，并且会持续到主动执行commit、rollback或断开连接时。

有些客户端连接框架会默认连接成功后执行set autocommit=0，这就导致接下来的查询都在事务中，这会导致意外的长事务。所以建议总是使用set autocommit=1，通过显式语句的方式来启动事务。

在commit时可以选择执行commit work and chain，这个命令时提交事务病自动启动下一个事务，省去了再次执行begin语句的开销。同时我们可以从程序开发的角度明确地知道每个语句是否处于事务中。

我们可以在information_schema库的innodb_trx这个表中查询长事务。



