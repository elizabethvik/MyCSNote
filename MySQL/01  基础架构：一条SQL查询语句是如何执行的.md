# 01 | 基础架构：一条SQL查询语句的执行

## MySQL的基本架构：<img src="01  基础架构：一条SQL查询语句是如何执行的.assets/数据库基本结构.jpg" alt="数据库基本结构" style="zoom:80%;" />

MySQL分为Server层和存储引擎层两部分。

- Server层：连接器、查询缓存、分析器、优化器、执行器。所有跨存储引擎的功能都在这一层实现，如存储过程、触发器、视图等。
- 存储引擎层：负责数据的存储和提取。架构模式：插件式。支持InnoDB、MyISAM、Memory等多个存储引擎。InnoDB是MySQL的默认存储引擎。*可以在create table语句中使用engine=xxx来指定使用某引擎建表。*

### 连接器

连接到数据库时，接待用户的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。在bash命令行的连接命令这么写：

```bash
mysql -h$ip -P$port -u$user -p
```

连接命令中mysql是客户端工具，用来和服务端建立连接。完成TCP握手后，连接器开始使用输入的用户名和密码认证身份。如果用户名和密码错误，会收到一个“Access denied for user”错误，客户端程序结束执行。如果认证通过，连接器会在权限表里查出你拥有的权限。之后，这个链接里的权限判断逻辑都会依赖于此时读到的权限。

链接完成后，如果没有后续的动作链接就处于空闲状态。可以用show processlist查看系统中的连接和连接状态。客户端如果太长时间无操作，连接器就会自动将其断开。时间由参数wait_timeout控制，默认值为8小时。

- 长连接：连接成功后，如果客户端持续有请求，则一直使用同一个连接。
- 短连接：每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

建立连接的过程通常比较复杂，建议尽量使用长连接。但是全部长连接有时会使内容占用很大，因为MySQL再执行过程中临时使用的内存是管理在连接对象中的，在连接断开的时候才会释放。所以长连接累积下来，可能导致内存占用太大，导致MySQL异常重启。

解决方案：

1. 定期断开长连接。使用一段时间，或是程序里面执行过一个占用内存的大查询后，断开连接再重连。
2. 可以在每次执行一个比较大的操作后，执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

### 查询缓存

MySQL拿到一个查询请求后，会先到查询缓存看看之前是否执行过这条语句。之前执行过的语句和结果可能会以key-value键值对的形式直接缓存在内存中。如果缓存中能找到这条语句，那么结果就会被直接返回给客户端。

如果语句不在查询缓存中，就会继续后面的阶段，执行完成后，结果会存入查询缓存中。

**但是，查询缓存的失效非常频繁，只要有队一张表的更新，这个表上的所有查询缓存都会被清空。**对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非业务有一张静态表，很长时间才会更新一次，才适合使用查询缓存。

MySQL提供查询缓存“按需使用”的方式。可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而要使用查询缓存的语句，可以用SQL_CACHE显式指定。

```sql
select SQL_CACHE * from T where ID=10;
```

*需要注意：MySQL 8.0版本将查询缓存的整块功能删掉了。*

### 分析器

没有命中查询缓存，就开始真正执行语句。

分析器会先做“词法分析”。分析器从输入的“select”关键词识别出这是一个查询语句，把字符串“T”识别成“表名T”，把字符串“ID”识别成“字段ID”。也就是说查询语句中的表结构内容（表名、字段）会在分析器阶段就识别出来。

完成识别后，会开始“语法分析”。如果语句不对，就会收到“You have an error in your SQL syntax”错误。

### 优化器

经过分析器，MySQL就知道你要做什么了。开始执行之前，还要经过优化器的处理。

优化器是在表中有多个索引的时候，决定使用哪个索引；或是在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

### 执行器

MySQL通过分析器知道了要做什么，通过优化器知道要怎么做，就进入执行器阶段开始执行。

开始执行时，首先判断用户对表是否有执行查询、修改的权限，如果没有，就会返回没有权限的错误。*在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候做权限验证。查询也会在优化器前调用precheck验证权限。*

如果有权限就打开表继续执行。执行器会根据表的引擎定义使用引擎提供的接口。

*查询的字段如果没有索引的话，就取表的第一行，判断是否是要查询的字段，如果不是跳过，如果是则将这行存在结果集中。调用引擎接口取下一行，一直重复相同的判断逻辑，直到这个表的最后一行。执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。*

至此，一条SQL语句的执行就完成了。

数据库的慢查询日志中有rows_examined的字段，表示这个语句执行过程中扫描了多少行，这个值是在执行器每次调用引擎获取数据行的时候累加的。

